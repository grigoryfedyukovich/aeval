Simplified goal: (forall ((Lst)) ((rev2 x nil)=(rev x)))

=========================
Assumptions [0]: (forall ((Lst)) ((append nil x)=x))
Assumptions [1]: (forall (INT (Lst) (Lst)) ((append (cons x y) z)=(cons x (append y z))))
Assumptions [2]: ((rev nil)=nil)
Assumptions [3]: (forall (INT (Lst)) ((rev (cons x y))=(append (rev y) (cons x nil))))
Assumptions [4]: (forall ((Lst)) ((rev2 nil a)=a))
Assumptions [5]: (forall (INT (Lst) (Lst)) ((rev2 (cons x t) a)=(rev2 t (cons x a))))

Base case:       ((rev2 nil nil)=(rev nil))
rewritten [2]:   ((rev2 nil nil)=nil)
rewritten [4]:   true
=========================
Assumptions [0]: (forall ((Lst)) ((append nil x)=x))
Assumptions [1]: (forall (INT (Lst) (Lst)) ((append (cons x y) z)=(cons x (append y z))))
Assumptions [2]: ((rev nil)=nil)
Assumptions [3]: (forall (INT (Lst)) ((rev (cons x y))=(append (rev y) (cons x nil))))
Assumptions [4]: (forall ((Lst)) ((rev2 nil a)=a))
Assumptions [5]: (forall (INT (Lst) (Lst)) ((rev2 (cons x t) a)=(rev2 t (cons x a))))
Assumptions [6]: ((rev2 _t_2 nil)=(rev _t_2))

Inductive step:  ((rev2 (cons _t_1 _t_2) nil)=(rev (cons _t_1 _t_2)))
rewritten [3]:   ((rev2 (cons _t_1 _t_2) nil)=(append (rev _t_2) (cons _t_1 nil)))
rewritten [5]:   ((rev2 _t_2 (cons _t_1 nil))=(append (rev _t_2) (cons _t_1 nil)))
backtrack to:    ((rev2 (cons _t_1 _t_2) nil)=(append (rev _t_2) (cons _t_1 nil)))
backtrack to:    ((rev2 (cons _t_1 _t_2) nil)=(rev (cons _t_1 _t_2)))
rewritten [5]:   ((rev2 _t_2 (cons _t_1 nil))=(rev (cons _t_1 _t_2)))
rewritten [3]:   ((rev2 _t_2 (cons _t_1 nil))=(append (rev _t_2) (cons _t_1 nil)))
backtrack to:    ((rev2 _t_2 (cons _t_1 nil))=(rev (cons _t_1 _t_2)))
backtrack to:    ((rev2 (cons _t_1 _t_2) nil)=(rev (cons _t_1 _t_2)))
                 Failed