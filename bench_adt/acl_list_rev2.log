ACL2 !>(defun rev2 (x a)
  (if (endp x)
      a
    (rev2 (cdr x) (cons (car x) a) )))

The admission of REV2 is trivial, using the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of REV2 is described by the
theorem (OR (CONSP (REV2 X A)) (EQUAL (REV2 X A) A)).  We used primitive
type reasoning.

Summary
Form:  ( DEFUN REV2 ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 REV2
ACL2 !>(defun rev (x)
  (if (endp x)
      nil
    (append (rev (cdr x))
            (list (car x)))))

The admission of REV is trivial, using the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of REV is described by the
theorem (TRUE-LISTP (REV X)).  We used primitive type reasoning and
the :type-prescription rules BINARY-APPEND and TRUE-LISTP-APPEND.

Summary
Form:  ( DEFUN REV ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:TYPE-PRESCRIPTION BINARY-APPEND)
        (:TYPE-PRESCRIPTION TRUE-LISTP-APPEND))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
 REV
ACL2 !>(defthm rev2-rev (equal (rev2 x nil) (rev x)))

*1 (the initial Goal, a key checkpoint) is pushed for proof by induction.

Perhaps we can prove *1 by induction.  Two induction schemes are suggested
by this conjecture.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (REV X).  This suggestion
was produced using the :induction rules REV and REV2.  If we let (:P X)
denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (ENDP X)) (:P (CDR X)))
              (:P X))
     (IMPLIES (ENDP X) (:P X))).
This induction is justified by the same argument used to admit REV.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.
Subgoal *1/2
Subgoal *1/2'
Subgoal *1/2''
Subgoal *1/2'''
Subgoal *1/2'4'
Subgoal *1/2'5'

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/2''
(IMPLIES (AND (CONSP X)
              (EQUAL (REV2 (CDR X) NIL)
                     (REV (CDR X))))
         (EQUAL (REV2 (CDR X) (LIST (CAR X)))
                (APPEND (REV (CDR X)) (LIST (CAR X)))))

*1.1 (Subgoal *1/2'5') is pushed for proof by induction.

])
Subgoal *1/1
Subgoal *1/1'

So we now return to *1.1, which is

(EQUAL (REV2 X2 (LIST X1))
       (APPEND (REV2 X2 NIL) (LIST X1))).
Subgoal *1.1/2
Subgoal *1.1/2'
Subgoal *1.1/2''
Subgoal *1.1/2'''
Subgoal *1.1/2'4'

*1.1.1 (Subgoal *1.1/2'4') is pushed for proof by induction.
Subgoal *1.1/1
Subgoal *1.1/1'

So we now return to *1.1.1, which is

(IMPLIES (EQUAL (REV2 X4 (LIST X1))
                (APPEND (REV2 X4 NIL) (LIST X1)))
         (EQUAL (REV2 X4 (LIST X3 X1))
                (APPEND (REV2 X4 (LIST X3))
                        (LIST X1)))).
Subgoal *1.1.1/3
Subgoal *1.1.1/3'
Subgoal *1.1.1/3''
Subgoal *1.1.1/3'''
Subgoal *1.1.1/3'4'

*1.1.1.1 (Subgoal *1.1.1/3'4') is pushed for proof by induction.
Subgoal *1.1.1/2
Subgoal *1.1.1/2'
Subgoal *1.1.1/2''
Subgoal *1.1.1/2'''
Subgoal *1.1.1/2'4'

*1.1.1.2 (Subgoal *1.1.1/2'4') is pushed for proof by induction.
Subgoal *1.1.1/1
Subgoal *1.1.1/1'

So we now return to *1.1.1.2, which is

(IMPLIES (AND (NOT (EQUAL (REV2 X6 (LIST X1))
                          (APPEND (REV2 X6 NIL) (LIST X1))))
              (EQUAL (REV2 X6 (LIST X5 X1))
                     (APPEND (REV2 X6 (LIST X5)) (LIST X1))))
         (EQUAL (REV2 X6 (LIST X5 X3 X1))
                (APPEND (REV2 X6 (LIST X5 X3))
                        (LIST X1)))).

The formula above is subsumed by one of its parents, *1.1, which we're
in the process of trying to prove by induction.  When an inductive
proof pushes a subgoal for induction that is less general than the
original goal, it may be a sign that either an inappropriate induction
was chosen or that the original goal is insufficiently general.  In
any case, our proof attempt has failed.

Summary
Form:  ( DEFTHM REV2-REV ...)
Rules: ((:DEFINITION BINARY-APPEND)
        (:DEFINITION ENDP)
        (:DEFINITION NOT)
        (:DEFINITION REV)
        (:DEFINITION REV2)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION REV)
        (:INDUCTION REV2)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS))
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  5244

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal
(EQUAL (REV2 X NIL) (REV X))

*** Key checkpoint under a top-level induction: ***

Subgoal *1/2''
(IMPLIES (AND (CONSP X)
              (EQUAL (REV2 (CDR X) NIL)
                     (REV (CDR X))))
         (EQUAL (REV2 (CDR X) (LIST (CAR X)))
                (APPEND (REV (CDR X)) (LIST (CAR X)))))

ACL2 Error in ( DEFTHM REV2-REV ...):  See :DOC failure.

******** FAILED ********