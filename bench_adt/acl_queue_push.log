ACL2 !>(defun rev (x)
  (if (endp x)
      nil
    (append (rev (cdr x))
            (list (car x)))))

The admission of REV is trivial, using the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of REV is described by the
theorem (TRUE-LISTP (REV X)).  We used primitive type reasoning and
the :type-prescription rules BINARY-APPEND and TRUE-LISTP-APPEND.

Summary
Form:  ( DEFUN REV ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:TYPE-PRESCRIPTION BINARY-APPEND)
        (:TYPE-PRESCRIPTION TRUE-LISTP-APPEND))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.01)
 REV
ACL2 !>(defthm qpush 
  (equal 
    (+ 1 (len x) (len y)) 
    (if (<= (len (cons n y)) (len x)) 
      (+ (len x) (len (cons n y))) 
      (+ (len (append x (rev (cons n y)))) (len nil))
    )))

ACL2 Warning [Free] in ( DEFTHM QPUSH ...):  A :REWRITE rule generated
from QPUSH contains the the free variable N on the right-hand side
of the rule, which is not bound on the left-hand side.  This can cause
new variables to be introduced into the proof, which may surprise you.


ACL2 Warning [Subsume] in ( DEFTHM QPUSH ...):  The previously added
rules COMMUTATIVITY-2-OF-+ and COMMUTATIVITY-OF-+ subsume a newly proposed
:REWRITE rule generated from QPUSH, in the sense that the old rules
rewrite more general targets.  Because the new rule will be tried first,
it may nonetheless find application.

Goal'
Goal''

([ A key checkpoint:

Goal''
(IMPLIES (< (LEN X) (+ 1 (LEN Y)))
         (EQUAL (+ 1 (LEN X) (LEN Y))
                (LEN (APPEND X (REV Y) (LIST N)))))

*1 (Goal'') is pushed for proof by induction.

])

Perhaps we can prove *1 by induction.  Six induction schemes are suggested
by this conjecture.  Subsumption reduces that number to four.  These
merge into two derived induction schemes.  One of these has a score
higher than the other.  

We will induct according to a scheme suggested by (REV Y).  This suggestion
was produced using the :induction rules LEN and REV.  If we let (:P N X Y)
denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (ENDP Y)) (:P N X (CDR Y)))
              (:P N X Y))
     (IMPLIES (ENDP Y) (:P N X Y))).
This induction is justified by the same argument used to admit REV.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.
Subgoal *1/3
Subgoal *1/3'
Subgoal *1/3''
Subgoal *1/3'''
Subgoal *1/3'4'
Subgoal *1/3'5'
Subgoal *1/3'6'
Subgoal *1/3'7'
Subgoal *1/3'8'
Subgoal *1/3'9'
Subgoal *1/3'10'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/3''
(IMPLIES (AND (CONSP Y)
              (EQUAL (+ 1 (LEN X) (LEN (CDR Y)))
                     (LEN (APPEND X (REV (CDR Y)) (LIST N))))
              (< (LEN X) (+ 2 (LEN (CDR Y)))))
         (EQUAL (+ 2 (LEN X) (LEN (CDR Y)))
                (LEN (APPEND X (APPEND (REV (CDR Y)) (LIST (CAR Y)))
                             (LIST N)))))

*1.1 (Subgoal *1/3'10') is pushed for proof by induction.

])
Subgoal *1/2
Subgoal *1/2'
Subgoal *1/2''
Subgoal *1/2'''
Subgoal *1/2'4'
Subgoal *1/2'5'
Subgoal *1/2'6'
Subgoal *1/2'7'
Subgoal *1/2'8'
Subgoal *1/2'9'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/2'''
(IMPLIES (AND (EQUAL (LEN (CDR Y)) (+ -1 (LEN X)))
              (CONSP Y)
              (<= (+ 1 (LEN (CDR Y))) (LEN X))
              (< (LEN X) (+ 2 (LEN (CDR Y)))))
         (EQUAL (+ 2 (LEN X) (LEN (CDR Y)))
                (LEN (APPEND X (APPEND (REV (CDR Y)) (LIST (CAR Y)))
                             (LIST N)))))

*1.2 (Subgoal *1/2'9') is pushed for proof by induction.

])
Subgoal *1/1
Subgoal *1/1'
Subgoal *1/1''
Subgoal *1/1'''
Subgoal *1/1'4'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/1'''
(IMPLIES (AND (EQUAL (LEN X) 0) (NOT (CONSP Y)))
         (EQUAL 1 (LEN (APPEND X (LIST N)))))

*1.3 (Subgoal *1/1'4') is pushed for proof by induction.

])

So we now return to *1.3, which is

(IMPLIES (EQUAL (LEN X) 0)
         (EQUAL 1 (LEN (APPEND X (LIST N))))).
Subgoal *1.3/3
Subgoal *1.3/3'
Subgoal *1.3/2
Subgoal *1.3/2'
Subgoal *1.3/1
Subgoal *1.3/1'

*1.3 is COMPLETED!
Thus key checkpoint Subgoal *1/1''' is COMPLETED!

We therefore turn our attention to *1.2, which is

(IMPLIES (AND (INTEGERP I)
              (<= 0 I)
              (<= I I)
              (< I (+ 1 I)))
         (EQUAL (+ 1 I I)
                (LEN (APPEND X (APPEND (REV Y2) (LIST Y1))
                             (LIST N))))).
Subgoal *1.2/2
Subgoal *1.2/2'
Subgoal *1.2/2''
Subgoal *1.2/2'''
Subgoal *1.2/2'4'
Subgoal *1.2/2'5'
Subgoal *1.2/2'6'
Subgoal *1.2/2'7'

*1.2.1 (Subgoal *1.2/2'7') is pushed for proof by induction.
Subgoal *1.2/1
Subgoal *1.2/1'
Subgoal *1.2/1''
Subgoal *1.2/1'''

*1.2.2 (Subgoal *1.2/1''') is pushed for proof by induction.

So we now return to *1.2.2, which is

(IMPLIES (AND (INTEGERP I)
              (<= 0 I)
              (<= I I)
              (< I (+ 1 I)))
         (EQUAL (+ 1 I I)
                (LEN (APPEND X (LIST Y1 N))))).
Subgoal *1.2.2/2
Subgoal *1.2.2/2'
Subgoal *1.2.2/2''
Subgoal *1.2.2/2'''
Subgoal *1.2.2/2'4'
Subgoal *1.2.2/2'5'

*1.2.2.1 (Subgoal *1.2.2/2'5') is pushed for proof by induction.
Subgoal *1.2.2/1
Subgoal *1.2.2/1'
Subgoal *1.2.2/1''
Subgoal *1.2.2/1'''

A goal of NIL, Subgoal *1.2.2/1''', has been generated!  Obviously,
the proof attempt has failed.

Summary
Form:  ( DEFTHM QPUSH ...)
Rules: ((:DEFINITION BINARY-APPEND)
        (:DEFINITION ENDP)
        (:DEFINITION FIX)
        (:DEFINITION LEN)
        (:DEFINITION NOT)
        (:DEFINITION REV)
        (:DEFINITION SYNP)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART LEN)
        (:EXECUTABLE-COUNTERPART NOT)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION BINARY-APPEND)
        (:INDUCTION LEN)
        (:INDUCTION REV)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE COMMUTATIVITY-2-OF-+)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:REWRITE UNICITY-OF-0)
        (:TYPE-PRESCRIPTION BINARY-APPEND)
        (:TYPE-PRESCRIPTION LEN)
        (:TYPE-PRESCRIPTION REV)
        (:TYPE-PRESCRIPTION TRUE-LISTP-APPEND))
Warnings:  Subsume and Free
Time:  0.05 seconds (prove: 0.04, print: 0.01, other: 0.00)
Prover steps counted:  10139

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(IMPLIES (< (LEN X) (+ 1 (LEN Y)))
         (EQUAL (+ 1 (LEN X) (LEN Y))
                (LEN (APPEND X (REV Y) (LIST N)))))

*** Key checkpoints under a top-level induction
    before generating a goal of NIL (see :DOC nil-goal): ***

Subgoal *1/3''
(IMPLIES (AND (CONSP Y)
              (EQUAL (+ 1 (LEN X) (LEN (CDR Y)))
                     (LEN (APPEND X (REV (CDR Y)) (LIST N))))
              (< (LEN X) (+ 2 (LEN (CDR Y)))))
         (EQUAL (+ 2 (LEN X) (LEN (CDR Y)))
                (LEN (APPEND X (APPEND (REV (CDR Y)) (LIST (CAR Y)))
                             (LIST N)))))

Subgoal *1/2'''
(IMPLIES (AND (EQUAL (LEN (CDR Y)) (+ -1 (LEN X)))
              (CONSP Y)
              (<= (+ 1 (LEN (CDR Y))) (LEN X))
              (< (LEN X) (+ 2 (LEN (CDR Y)))))
         (EQUAL (+ 2 (LEN X) (LEN (CDR Y)))
                (LEN (APPEND X (APPEND (REV (CDR Y)) (LIST (CAR Y)))
                             (LIST N)))))

ACL2 Error in ( DEFTHM QPUSH ...):  See :DOC failure.

******** FAILED ********